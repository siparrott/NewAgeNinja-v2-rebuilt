So the “AI Autoblog” feature is mainly wiring these together plus adding an image upload + orchestration endpoint.

Below is the recommended implementation plan, then copy-paste task prompts for Replit (sequenced / idempotent). Skim the diagram first; then dive in.

1. High-Level Data Flow
text
Kopieren
Bearbeiten
User (Admin UI) 
   ↓ uploads ≤3 images + selects "Generate Blog"
Frontend (AutoBlogChat widget)
   ↓ POST /api/autoblog/start   (multipart: images + optional user text: theme/tags/service)
Backend (Express or Supabase Fn)
   1. Auth user (Supabase session JWT)
   2. Store images (Supabase Storage or tmp S3-like bucket) → get public URLs (resized)
   3. Scrape user's public site URL(s) via ScrapingAgent (server/scraping-agent.ts) → structured context
   4. Build Assistant prompt (system + context + user request + image URLs)
   5. Call OpenAI Assistants (responses streamed)
   6. Validate+Parse assistant JSON (safe schema)
   7. Create blog post record (storage.createBlogPost OR POST /api/blog/posts)
   8. Return blog post id + slug
Frontend
   ↓ show spinner → redirect to AdminBlogEditPage(slug) for review OR auto-publish
Public Site
   ↓ blog appears within ~1 min
2. Data Contract: Assistant Output JSON
Have the model return strict JSON in a fenced code block (or better: function/tool call) so parsing is robust.

json
Kopieren
Bearbeiten
{
  "title": "Familienfotos in Wien: ...",
  "keyphrase": "Familienfotos Wien",
  "slug": "familienfotos-wien-juli-2025",
  "excerpt": "Kurzer Teaser (max 155 Zeichen, no HTML).",
  "content_html": "<h2>...</h2> ... full HTML ...",
  "seo_title": "Familienfotos Wien – Studio 1050 | New Age Fotografie",
  "meta_description": "Familienfotos Wien im Studio 1050 – natürliche Portraits ...",
  "cover_image": "https://.../public/path/first-image.jpg",
  "image_alts": [
    "Familie lachend im Studio 1050 Wien",
    "Papa hält Baby ...",
    "Detailhände Babyfotografie"
  ],
  "tags": ["Familie", "Studio", "Wien"],
  "status": "PUBLISHED",             // or "DRAFT" if you want manual approval
  "publish_now": true,
  "language": "de"                    // helps your i18n
}
Important formatting rules the Assistant must obey:

Rule	Why	Enforce In Prompt
Max 1 internal link (anchor keyword) – user requirement	Avoid spam; Yoast friendly	Use <a href="/warteliste/">Termin buchen</a> once unless user gives alt path
At least 1 external outbound link to a non-competing source	SEO trust	Provide <a href="https://www.wko.at/..."> etc. (assistant chooses relevant authority)
Keyphrase appears in intro, SEO title, meta description & at least 2x body	Yoast	Validate pre-publish
Paragraphs < 300 words	User style	Assistant told to hard wrap
Mix short/snappy sentences	Brand tone	In system prompt

3. Where to Plug In (Reviewed Codebase)
What you already have	Path	Re-use	Notes
Blog CRUD & admin pages	/server/routes.ts & /client/src/pages/admin/AdminBlog*	YES	Use server API not direct Supabase for consistent auth/validation.
Supabase client	/client/src/lib/supabase.ts	YES	Use session token for auth header when hitting your Express server.
Scraper	/server/scraping-agent.ts	YES (extend)	Add “summarizeForPrompt()` trimmed for token budget.
Chat widget skeleton	/client/src/components/chat/OpenAIAssistantChat.tsx	FORK → AutoBlogChat.tsx	Add image dropzone + generate button.
Assistant endpoint examples	/client/src/api/openai-assistant-endpoints.ts	TEMPLATE	Convert to Node/Express route /api/autoblog/start.

4. Backend Build (Express)
We’ll add two new routes:

POST /api/autoblog/start (multipart)

GET /api/autoblog/status/:jobId (optional polling; or stream SSE)

And a helper module: /server/autoblog.ts.

4.1 Environment Vars (server)
Add to .env & Replit Secrets:

OPENAI_API_KEY=...

PUBLIC_SITE_BASE_URL=https://www.newagefotografie.com (or per-studio runtime)

INTERNAL_WARTELISTE_PATH=/warteliste/

MAX_AUTOBLOG_IMAGES=3

OPENAI_ASSISTANT_ID=asst_... (if pre-created)

4.2 Autoblog Orchestrator (pseudo-code)
ts
Kopieren
Bearbeiten
// server/autoblog.ts
import { ScrapingAgent } from './scraping-agent';
import { storage } from './storage';
import OpenAI from 'openai';
import sharp from 'sharp';
import { v4 as uuid } from 'uuid';

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function runAutoBlog({
  userId,
  siteUrl,
  files,           // raw uploaded image buffers
  userPrompt,      // optional "make it funny", "focus on newborn", etc.
  language = 'de'
}) {
  // 1. Resize/compress -> public URLs
  const uploaded = await uploadAndResize(files); // returns [{url,altSuggested},...]
  
  // 2. Scrape site
  const scraped = await ScrapingAgent.scrapeWebsite(siteUrl);
  const promptContext = summarizeScrape(scraped); // trimmed strings
  
  // 3. Build messages
  const sys = buildSystemPrompt();      // see §5
  const usr = buildUserMessage({promptContext, userPrompt, uploaded, language});
  
  // 4. Send to OpenAI (Vision aware)
  const completion = await openai.chat.completions.create({
    model: "gpt-4o-mini",  // fast + vision
    temperature: 0.7,
    response_format: { type: "json_schema", json_schema: autoBlogSchema }, // optional strict
    messages: [
      { role: "system", content: sys },
      {
        role: "user",
        content: [
          { type: "text", text: usr },
          ...uploaded.map(img => ({ type: "image_url", image_url: { url: img.url } }))
        ]
      }
    ]
  });

  const data = JSON.parse(completion.choices[0].message.content!);

  // 5. Persist blog
  const newPost = await storage.createBlogPost({
    title: data.title,
    slug: data.slug,
    excerpt: data.excerpt,
    content: stripHtml(data.content_html), // plain text required by schema
    content_html: data.content_html,
    cover_image: data.cover_image || uploaded[0]?.url || null,
    status: data.status === 'PUBLISHED' ? 'PUBLISHED' : 'DRAFT',
    published_at: data.publish_now ? new Date() : null,
    seo_title: data.seo_title,
    meta_description: data.meta_description,
    tags: data.tags || [],
    author_id: userId,
  });

  // 6. Return result
  return { post: newPost, ai: data };
}
5. System Prompt Template (Copy/Paste)
Use this when creating the Assistant in OpenAI (dashboard) or when passing system in API call.
Customize {STUDIO_NAME}, {INTERNAL_LINK_PATH}, etc.

csharp
Kopieren
Bearbeiten
You are the AutoBlog Assistant for {STUDIO_NAME}, a portrait photography CRM & publishing platform (TogNinja).

GOAL: Convert up to 3 uploaded client images + live website context into a fully formatted, YOAST-friendly blog post ready to publish on the user's photography website.

STYLE:
- Founder-led, mentor tone. Local Vienna focus unless another location supplied.
- Short, snappy sentences. Occasional fragments allowed. Conversational.
- Mix pro tips + human anecdote. Avoid corporate fluff.
- Paragraphs < 300 words.
- Use German if `language=de`, English if `language=en`, else follow user instructions.

SEO RULES:
- Choose a short 2–4 word KEYPHRASE (local if possible, e.g., "Familienfotos Wien").
- Include keyphrase in intro, SEO title, meta description, and ≥2x body.
- Provide `slug` (kebab-case).
- Provide `excerpt` (≤155 chars, plain text).
- Add **one** internal anchor link to `{INTERNAL_LINK_PATH}` using natural anchor text (e.g., "Termin buchen" or "Warteliste Studio 1050").
- Add **one** outbound link to a high-authority, non-competitor resource relevant to the topic (no spam; .org/.gov/.edu preferred when possible).

IMAGES:
- Use first uploaded image as cover unless user overrides.
- Suggest alt text for each uploaded image.

OUTPUT:
Return STRICT JSON ONLY (no commentary) matching the schema I give you.
All HTML in `content_html` must be self-contained, valid, and safe (no script tags).
Use <h2> and <h3> subheadings; include lists & tables where helpful.

CONTEXT:
Below is structured website data & user instructions. Use it to reflect studio voice, pricing tiers, local districts, languages, offers.

{CONTEXT_BLOCK}
6. JSON Schema for Strict Validation (inline TypeBox-like)
ts
Kopieren
Bearbeiten
export const autoBlogSchema = {
  name: "autoblog_post",
  schema: {
    type: "object",
    required: ["title", "keyphrase", "slug", "excerpt", "content_html", "seo_title", "meta_description"],
    properties: {
      title: { type: "string", maxLength: 140 },
      keyphrase: { type: "string", maxLength: 60 },
      slug: { type: "string", pattern: "^[a-z0-9\\-]+$" },
      excerpt: { type: "string", maxLength: 180 },
      content_html: { type: "string" },
      seo_title: { type: "string", maxLength: 70 },
      meta_description: { type: "string", maxLength: 160 },
      cover_image: { type: "string", nullable: true },
      image_alts: { type: "array", items: { type: "string" }, maxItems: 3 },
      tags: { type: "array", items: { type: "string" }, maxItems: 10 },
      status: { type: "string", enum: ["DRAFT", "PUBLISHED"] },
      publish_now: { type: "boolean" },
      language: { type: "string" }
    }
  },
  strict: true
};
7. Frontend UI: AutoBlogChat.tsx
UX Flow:

Floating purple “AutoBlog” button on Blog Admin pages.

Modal opens:

Dropzone (max 3 images; auto compress client-side via canvas).

Quick tags chips: Family / Newborn / Maternity / Corporate / Custom.

Text box: “Anything special to mention?”

Language select.

Generate button.

Progress states: Uploading → AI Writing → Creating Post → Done.

On success: link buttons:

“Open in Editor” (AdminBlogEditPage)

“View Live Post” (public slug)

“Generate Another”

You already have UI building blocks (buttons, toasts, spinners). Borrow patterns from OpenAIAssistantChat.tsx & AdminBlogNewPage.tsx.

8. Replit Step-By-Step Task Prompts
Below are copy/paste prompts you can feed to Replit Ghostwriter (or use manually). I’ve broken them into atomic tasks so you can check in between.

Task 0 – Create Feature Branch
bash
Kopieren
Bearbeiten
git checkout -b feature/autoblog-assistant
Task 1 – Install Dependencies
In Replit shell:

nginx
Kopieren
Bearbeiten
npm install openai sharp multer zod
(If you’re using Deno Edge Fn instead of Express for prod, skip multer and handle formData natively. For now: Express dev path.)

Task 2 – Add Env Vars
Edit .env.demo & your Replit Secrets UI:

ini
Kopieren
Bearbeiten
OPENAI_API_KEY=YOUR_KEY
PUBLIC_SITE_BASE_URL=https://www.newagefotografie.com
INTERNAL_WARTELISTE_PATH=/warteliste/
OPENAI_ASSISTANT_ID=asst_xxxxxx   # optional; leave blank to use raw chat.completions
MAX_AUTOBLOG_IMAGES=3
Commit but DO NOT push real key.

Task 3 – Create server/autoblog.ts
Add new file:

ts
Kopieren
Bearbeiten
// server/autoblog.ts
import type { Request } from "express";
import OpenAI from "openai";
import { storage } from "./storage";
import { ScrapingAgent } from "./scraping-agent";
import sharp from "sharp";
import path from "path";
import fs from "fs/promises";
import { randomUUID } from "crypto";
import { stripHtml } from "./util-strip-html"; // create helper if missing
import { autoBlogSchema } from "./autoblog-schema"; // create separate file (Task 4)
import { z } from "zod";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function handleAutoBlog({
  userId,
  studioSiteUrl,
  imagePaths,      // tmp server paths
  userPrompt,
  language = "de",
}: {
  userId: string;
  studioSiteUrl: string;
  imagePaths: string[];
  userPrompt?: string;
  language?: string;
}) {
  // 1. Resize images & move to public storage
  const uploaded = await Promise.all(imagePaths.slice(0,3).map(processAndStoreImage));

  // 2. Scrape site
  const scraped = await ScrapingAgent.scrapeWebsite(studioSiteUrl);
  const contextBlock = summarizeForPrompt(scraped);

  // 3. Build messages & call OpenAI
  const { result, raw } = await callOpenAIForBlog({
    contextBlock,
    uploaded,
    userPrompt,
    language,
  });

  // 4. Validate JSON
  const parsed = autoBlogSchema.parse(result);

  // 5. Persist blog
  const newPost = await storage.createBlogPost({
    title: parsed.title,
    slug: parsed.slug,
    excerpt: parsed.excerpt,
    content: stripHtml(parsed.content_html),
    content_html: parsed.content_html,
    cover_image: parsed.cover_image || uploaded[0]?.url || null,
    status: parsed.status,
    published_at: parsed.publish_now ? new Date() : null,
    seo_title: parsed.seo_title,
    meta_description: parsed.meta_description,
    tags: parsed.tags ?? [],
    author_id: userId,
  });

  // 6. Return payload
  return { post: newPost, ai: parsed, raw };
}
(You’ll fill in helper functions in later tasks.)

Task 4 – Schema + Helpers
Create server/autoblog-schema.ts:

ts
Kopieren
Bearbeiten
import { z } from "zod";

export const autoBlogSchema = z.object({
  title: z.string().max(140),
  keyphrase: z.string().max(60),
  slug: z.string().regex(/^[a-z0-9\-]+$/),
  excerpt: z.string().max(180),
  content_html: z.string(),
  seo_title: z.string().max(70),
  meta_description: z.string().max(160),
  cover_image: z.string().url().optional().nullable(),
  image_alts: z.array(z.string()).max(3).optional(),
  tags: z.array(z.string()).max(10).optional(),
  status: z.enum(["DRAFT","PUBLISHED"]).default("DRAFT"),
  publish_now: z.boolean().default(false),
  language: z.string().default("de")
});

export type AutoBlogParsed = z.infer<typeof autoBlogSchema>;
Create server/util-strip-html.ts:

ts
Kopieren
Bearbeiten
export function stripHtml(html: string): string {
  return html
    .replace(/<style[\s\S]*?<\/style>/gi, "")
    .replace(/<script[\s\S]*?<\/script>/gi, "")
    .replace(/<[^>]+>/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}
Task 5 – Image Process + Storage Helper
Append to server/autoblog.ts (below imports):

ts
Kopieren
Bearbeiten
async function processAndStoreImage(tmpPath: string) {
  const buf = await fs.readFile(tmpPath);
  const resized = await sharp(buf).resize(1600, null, { fit: "inside" }).jpeg({ quality: 75 }).toBuffer();
  const filename = `${randomUUID()}.jpg`;
  // You likely already have storage methods; if not, push to /public/uploads/ or Supabase bucket
  const url = await storage.savePublicAsset("blog-images", filename, resized); // implement in storage.ts
  return { url, filename };
}
Add savePublicAsset to /server/storage.ts (if missing). Minimal version storing to local public/ when running in Replit; production = Supabase storage.

Task 6 – Summarize Scrape for Prompt
Add to server/autoblog.ts:

ts
Kopieren
Bearbeiten
function summarizeForPrompt(scraped: any): string {
  // Trim long content; focus on brand voice, services, location, price cues
  const about = (scraped?.content?.aboutText || "").slice(0, 1200);
  const services = (scraped?.content?.services || []).slice(0, 10).join("; ");
  const contact = scraped?.content?.contactInfo?.address ?? "";
  const seo = JSON.stringify(scraped?.seoAnalysis ?? {});
  return `
ABOUT:
${about}

SERVICES:
${services}

LOCATION:
${contact}

SEO_INSIGHTS:
${seo}
  `.trim();
}
Task 7 – Build Prompt + OpenAI Call
Still in server/autoblog.ts:

ts
Kopieren
Bearbeiten
function buildSystemPrompt() {
  const internalPath = process.env.INTERNAL_WARTELISTE_PATH || "/warteliste/";
  const studio = process.env.STUDIO_NAME || "New Age Fotografie";
  return `You are the AutoBlog Assistant for ${studio} ... [PASTE SYSTEM PROMPT FROM §5 HERE] ...`;
}

function buildUserMessage({contextBlock, userPrompt, uploaded, language}: any) {
  return `
User wants an autoblog article. Language=${language}.
User hint: ${userPrompt || "None"}.

Images provided (${uploaded.length}):
${uploaded.map((u,i)=>`[${i+1}] ${u.url}`).join("\n")}

Context:
${contextBlock}
`;
}

async function callOpenAIForBlog({contextBlock, uploaded, userPrompt, language}: any) {
  const system = buildSystemPrompt();
  const user = buildUserMessage({contextBlock, uploaded, userPrompt, language});

  const messages: any[] = [
    { role: "system", content: system },
    { 
      role: "user",
      content: [
        { type: "text", text: user },
        ...uploaded.map((u: any) => ({ type:"image_url", image_url:{url:u.url} }))
      ]
    }
  ];

  const completion = await openai.chat.completions.create({
    model: "gpt-4o-mini",
    temperature: 0.7,
    response_format: { type: "json_object" },
    messages
  });

  const text = completion.choices[0].message.content ?? "{}";
  let parsed: any;
  try { parsed = JSON.parse(text); } catch { parsed = {}; }

  return { result: parsed, raw: completion };
}
Task 8 – Express Route Wiring
Open /server/routes.ts and add (near other routes, before export):

ts
Kopieren
Bearbeiten
import multer from "multer";
import { handleAutoBlog } from "./autoblog";

const upload = multer({ dest: "tmp-autoblog/" });

app.post("/api/autoblog/start", authenticateUser, upload.array("images", 3), async (req, res) => {
  try {
    const userId = (req as any).user?.id || "anonymous";
    const siteUrl = req.body.siteUrl || process.env.PUBLIC_SITE_BASE_URL;
    const userPrompt = req.body.userPrompt;
    const language = req.body.language || "de";
    const imagePaths = (req.files as Express.Multer.File[]).map(f => f.path);

    const result = await handleAutoBlog({
      userId,
      studioSiteUrl: siteUrl,
      imagePaths,
      userPrompt,
      language
    });

    res.json(result);
  } catch (err: any) {
    console.error("Autoblog error", err);
    res.status(500).json({ error: err.message || "Autoblog failed" });
  }
});
(Optional) Add GET /api/autoblog/status/:jobId if you move to background queue later.

Task 9 – Storage: savePublicAsset
Modify /server/storage.ts:

ts
Kopieren
Bearbeiten
import fs from "fs/promises";
import path from "path";
import { mkdir } from "fs/promises";

const PUBLIC_UPLOAD_DIR = path.join(process.cwd(), "public", "uploads");

export async function savePublicAsset(bucket: string, filename: string, buf: Buffer) {
  const dir = path.join(PUBLIC_UPLOAD_DIR, bucket);
  await mkdir(dir, { recursive: true });
  const full = path.join(dir, filename);
  await fs.writeFile(full, buf);
  // In dev express may serve /public; ensure static mount in server/index.ts
  return `/uploads/${bucket}/${filename}`;
}
Make sure Express serves public/:

In /server/index.ts (if not present):

ts
Kopieren
Bearbeiten
import express from "express";
app.use("/uploads", express.static(path.join(process.cwd(), "public", "uploads")));
Task 10 – Frontend: New Component
Create client/src/components/chat/AutoBlogChat.tsx (copy trimmed from OpenAIAssistantChat.tsx but simplified). Skeleton:

tsx
Kopieren
Bearbeiten
import React, { useState } from "react";
import axios from "axios";

export function AutoBlogChat({ defaultSiteUrl, onCreated }: {
  defaultSiteUrl?: string;
  onCreated?: (post:any)=>void;
}) {
  const [files, setFiles] = useState<File[]>([]);
  const [prompt, setPrompt] = useState("");
  const [language, setLanguage] = useState<"de"|"en">("de");
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<any>(null);
  const [error, setError] = useState<string|null>(null);

  async function handleGenerate() {
    setLoading(true); setError(null);
    const form = new FormData();
    files.slice(0,3).forEach(f => form.append("images", f));
    form.append("userPrompt", prompt);
    form.append("language", language);
    form.append("siteUrl", defaultSiteUrl || window.location.origin);

    try {
      const { data } = await axios.post("/api/autoblog/start", form, { headers:{ "Content-Type":"multipart/form-data" }});
      setResult(data);
      onCreated?.(data.post);
    } catch (e:any) {
      setError(e?.response?.data?.error || e.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="autoblog-widget">
      {/* dropzone */}
      {/* prompt, language select */}
      <button disabled={!files.length || loading} onClick={handleGenerate}>
        {loading ? "Generating…" : "Generate Blog"}
      </button>
      {error && <div className="text-red-600">{error}</div>}
      {result && (
        <div className="mt-4">
          <p>AI Blog created: {result.post?.title}</p>
          <a href={`/admin/blog/${result.post?.slug}/edit`} className="btn">Edit</a>
          {result.post?.slug && <a href={`/blog/${result.post.slug}`} className="btn">View Live</a>}
        </div>
      )}
    </div>
  );
}
Task 11 – Mount Widget in Admin Blog UI
Edit /client/src/pages/admin/AdminBlogNewPage.tsx and/or AdminBlogPostsPage.tsx:

tsx
Kopieren
Bearbeiten
import { AutoBlogChat } from "../../components/chat/AutoBlogChat";
// ...
<AutoBlogChat defaultSiteUrl={window.location.origin.replace("/admin","")} onCreated={(post)=>console.log("AutoBlog created",post)} />
Place it high enough that admins see the “Generate from Images” CTA.

Task 12 – YOAST Field Validation Client-Side
After AI returns JSON, before sending to /api/blog/posts you could offer a quick review modal showing traffic lights:

Check	Pass/Fail	Fix button
Keyphrase in intro	✅/❌	highlight
Meta description contains keyphrase	✅/❌	auto fix
Internal link present	✅/❌	auto inject if missing
External link present	✅/❌	auto inject if missing

Basic regex checks; you already have UI patterns in AdvancedBlogPostForm.tsx.

Task 13 – Test Locally
npm run dev (server + client).

Log in.

Go to Blog Admin.

Upload 3 test JPGs.

Click Generate.

Confirm blog saved in DB (Supabase table blog_posts).

Confirm public route /blog/:slug renders.

Task 14 – Commit & Push
sql
Kopieren
Bearbeiten
git add .
git commit -m "feat(autoblog): AI image→blog autoblogger with site scrape"
git push origin feature/autoblog-assistant
Open PR, review diff.

9. Minimal JSON Validator Hook (Server Safety)
Before persisting, sanitize:

ts
Kopieren
Bearbeiten
function sanitizeHtml(html: string): string {
  return html
    .replace(/<script[\s\S]*?<\/script>/gi,"")
    .replace(/on\w+="[^"]*"/g,"")  // strip inline JS
    .trim();
}
Call before storage.

10. Handling Multi-Studio / White-Label
If TogNinja hosts many studios:

Pass studioId in JWT/session.

Look up studio domain + brand voice snippet from DB.

Use that in buildSystemPrompt() instead of global env.

Optional: stash studio-specific instruction doc in Supabase + embed retrieval.

11. Performance & Cost Tips
Lever	Why	Setting
Use gpt-4o-mini for fast/cheap drafts	3-image context OK	Default
Retry with gpt-4.1-mini if JSON invalid	Better reasoning	Fallback
Limit scrape to top 100k chars then compress	Control tokens	Already in summarize helper
Cache site scrape per studio for 1h	Avoid repeated fetches	server memory or KV

12. Future Upgrades
Add background queue (BullMQ / Supabase queue) to scale heavy requests.

Add content variants (short social post / long guide / English translation).

Add auto-image alt rewrite for accessibility scoring.

Add auto-internal linking suggestions using DB of your slugs.

13. Quick Smoke Checklist Before Shipping
 Upload limit enforced (3).

 Accepts PNG/JPG only; rejects >5MB.

 Scraper gracefully fails → still generate from userPrompt + images.

 HTML sanitized.

 Blog slug uniqueness (append -2 etc.).

 Internal link inserted once.

 External link uses rel="noopener nofollow external" if you want.

 Works in German & English.

Example Assistant Response (German, Family Shoot)
json
Kopieren
Bearbeiten
{
  "title": "Familienfotos Wien: Echtes Lachen im Studio 1050",
  "keyphrase": "Familienfotos Wien",
  "slug": "familienfotos-wien-studio-1050-juli-2025",
  "excerpt": "Locker, lustig, echt. So laufen Familienfotos in unserem Studio 1050 Wien.",
  "content_html": "<p>...intro incl keyphrase...</p><h2>Wie wir das Shooting aufgebaut haben</h2>...<p>Jetzt Termin sichern: <a href=\"/warteliste/\">Termin buchen</a></p><p>Mehr zu natürlichen Familienportraits: <a href=\"https://www.wko.at/branchen/wien/freizeitwirtschaft/fotografie.html\" target=\"_blank\" rel=\"noopener\">Fotografie Infos WKO</a></p>",
  "seo_title": "Familienfotos Wien – Studio 1050 | New Age Fotografie",
  "meta_description": "Familienfotos Wien im Studio 1050: natürliche Portraits, bis 15 Personen + Haustiere. Jetzt Termin sichern.",
  "cover_image": "https://cdn.example.com/blog-images/abc123.jpg",
  "image_alts": [
    "Familie lacht im Studio 1050 Wien",
    "Papa hebt Baby hoch bei Familienfotos",
    "Detailaufnahme Hände der Familie"
  ],
  "tags": ["Familie","Studio","Wien"],
  "status": "PUBLISHED",
  "publish_now": true,
  "language": "de"
}
